{"version":3,"sources":["../auth.js"],"names":["createTokens","user","secret1","secret2","createToken","jwt","sign","_","pick","expiresIn","createRefreshToken","refreshTokens","token","refreshToken","models","SECRET1","userId","decode","id","User","findOne","where","raw","verify","refreshSecret","newToken","newRefreshToken","tryLogin","email","password","SECRET2","ok","errors","path","message","bcrypt","compare","valid","refreshTokenSecret","userInfo"],"mappings":"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","sourcesContent":["import jwt from 'jsonwebtoken';\nimport _ from 'lodash';\nimport bcrypt from 'bcrypt';\n\n/**\n * Creates the auth tokens.\n *\n * @param      {String}  user     The user.\n * @param      {String}  secret1  The secret.\n * @param      {String}  secret2  The secret 2.\n */\nexport const createTokens = async (user, secret1, secret2) => {\n  const createToken = jwt.sign(\n    {\n      user: _.pick(user, ['id', 'username']),\n    },\n    secret1,\n    {\n      expiresIn: '1h',\n    },\n  );\n\n  const createRefreshToken = jwt.sign(\n    {\n      user: _.pick(user, ['id', 'username']),\n    },\n    secret2,\n    {\n      expiresIn: '7d',\n    },\n  );\n\n  return [createToken, createRefreshToken];\n};\n\n/**\n * Refreshes a users auth tokens.\n *\n * @param      {String}  token         The token.\n * @param      {String}  refreshToken  The refresh token.\n * @param      {Object}  models        The models.\n * @param      {String}  SECRET1        The secret.\n */\nexport const refreshTokens = async (token, refreshToken, models, SECRET1) => {\n  let userId = -1;\n  try {\n    const {\n      user: { id },\n    } = jwt.decode(refreshToken);\n    userId = id;\n  } catch (err) {\n    return {};\n  }\n\n  if (!userId) {\n    return {};\n  }\n\n  const user = await models.User.findOne({ where: { id: userId }, raw: true });\n\n  if (!user) {\n    return {};\n  }\n\n  try {\n    jwt.verify(refreshToken, user.refreshSecret);\n  } catch (err) {\n    return {};\n  }\n\n  const [newToken, newRefreshToken] = await createTokens(user, SECRET1, user.refreshSecret);\n  return {\n    token: newToken,\n    refreshToken: newRefreshToken,\n    user,\n  };\n};\n\n/**\n * Logs a user in.\n *\n * @param      {String}  email     The email.\n * @param      {String}  password  The password.\n * @param      {Object}  models    The models.\n * @param      {String}  SECRET1   The secret.\n * @param      {String}  SECRET2   The secret 2.\n */\nexport const tryLogin = async (email, password, models, SECRET1, SECRET2) => {\n  const user = await models.User.findOne({ where: { email }, raw: true });\n\n  if (!user) {\n    // user with provided email not found\n    return {\n      ok: false,\n      errors: [{ path: '', message: 'Invalid email or password.' }],\n    };\n  }\n\n  const valid = await bcrypt.compare(password, user.password);\n  if (!valid) {\n    // bad password\n    return {\n      ok: false,\n      errors: [{ path: '', message: 'Invalid email or password.' }],\n    };\n  }\n\n  const refreshTokenSecret = user.password + SECRET2;\n\n  const [token, refreshToken] = await createTokens(user, SECRET1, refreshTokenSecret);\n\n  return {\n    userInfo: user,\n    ok: true,\n    token,\n    refreshToken,\n  };\n};\n"],"file":"auth.js"}